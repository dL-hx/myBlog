# 前端面试手写题集合

## 1. 发布订阅模式

```js

```

## 2. 防抖函数

```js
const func = function (e) { // @TODO
  console.log(e.target.value);
  rederCity(this.value);
};
const debounce = function (func, wait) {
  let timerId;
  return function (...args) {
    let _this = this;
    clearTimeout(timerId);
    timerId = setTimeout(() => {
      func.apply(_this, args);
    }, wait);
  };
};

const debounceFunc = debounce(func, 500);

document.getElementById("search-input").addEventListener("input", debounceFunc);

```

## 3. 节流函数

```js

const func = function (e) {
  console.log('timeupdate触发')
  console.log('e:', e)
  localStorage.setItem('currentTime', this.currentTime)
}


function throttle(func, wait = 0) {
  // TODO
  let timeId
  return function (...args) {
    let _this = this
    if (timeId) {
        return;
    }

    timeId = setTimeout(() => {
      func.apply(_this, args)
      timeId = undefined
    }, wait)
  }
}


const throttleFn = throttle(func, 1000)
video.addEventListener('timeupdate', throttleFn)


```

## 4. 数组去重

### 方法一：使用Set
```js
function uniqueArray(arr) {// @TODO
  return [...new Set(arr)];
}
```

### 方法二：使用filter
```js
function uniqueArray(arr) {// @TODO
  return arr.filter((item, index, self) => {
    return self.indexOf(item) === index;
  });
}
```

### 方法三：使用reduce
```js
function uniqueArray(arr) {// @TODO
  return arr.reduce((prev, curr) => {
    return prev.includes(curr) ? prev : [...prev, curr];
  }, []);
}
```

## 5. 数组扁平化

```js
function flatten(arr) {// @TODO
  const result = [];
  
  function flat(arr) {
    for (let i = 0; i < arr.length; i++) {
      if (Array.isArray(arr[i])) {
        flat(arr[i]);
      } else {
        result.push(arr[i]);
      }
    }
  }
  
  flat(arr);
  return result;
}

// 简化版本
function flattenES6(arr) {
  return arr.flat(Infinity);
}
```

## 6. 手写Promise.all

```js
Promise.myAll = function(promises) {// @TODO

};
```

## 7. 手写Promise.allSettled

```js
Promise.myAllSettled = function(promises) {// @TODO
 
};
```

## 8. 手写call方法

```js
Function.prototype.myCall = function(context = window, ...args) {// @TODO
 
};
```

## 9. 手写apply方法

```js
Function.prototype.myApply = function(context = window, args = []) {// @TODO

};
```

## 10. 手写bind方法

```js
Function.prototype.myBind = function(context = window, ...args1) {// @TODO

};
```

## 11. 手写new操作符

```js
function myNew(constructor, ...args) {// @TODO

}
```

## 12. 手写instanceof

```js
function myInstanceof(obj, constructor) {// @TODO
 
}
```

## 13. 函数柯里化
将多个参数的函数，转换为单个参数的函数 
```js
function curriedAdd(a) {// @TODO
  return function(b){
    return function(c){
      return a + b + c;
    }
  }
}


console.log(curriedAdd(1)(2)(3)); // 6

```



```js
// 需求： 改写函数，实现如下效果

// 思路：
// 1. 保存不定长参数 array
// 2. 是否达到长度
// 3. 累加5个参数， 返回函数

let nums = []
function sum(...args) {// @TODO
	nums.push(...args)
	if(nums.length>=5){
		const res = nums.slice(0, 5).reduce((p,v)=> p + v, 0)
		nums = [] // 注意累加之后需要清空数组，保证下次累加的值是正确的
		return res
	}else{
		return sum
	}
}

// 使用示例
function sum(a, b, c, d, e) {
  return a + b + c + d + e;
}
sum(1)(2)(3)(4)(5)
sum(1)(2, 3)(4)(5)
sum(1)(2, 3, 4)(5)
sum(1, 2, 3)(4, 5)


```

![alt text](assets/前端面试题/Snipaste_2025-11-07_15-59-59.png)


### 优化版本

```js
function sumMaker(length) {
	let nums = []
	function sum(...args) {// @TODO
		nums.push(...args)
		if(nums.length>=length){
		const res = nums.slice(0, length).reduce((p,v)=> p + v, 0)
		nums = [] // 注意累加之后需要清空数组，保证下次累加的值是正确的
		return res
		}else{
			return sum
		}
	}
	return sum
}



const sum6 = sumMaker(6)
sum6(1)(2)(3)(4)(5)


const sum4 = sumMaker(4)
sum4(1)(2)(3)(4)
```

### 柯里化应用--判断类型
**参数复用：** 为函数预制通用参数，供给多次重复调用

![alt text](assets/前端面试题/Snipaste_2025-11-07_16-22-33.png)


```js
const typeOfTest = function(type){
  return function(obj){
    // return Object.prototype.toString.call(obj) === `[object ${type}]`
    return typeof obj === type
  }
}


const isString = typeOfTest('string')
const isNumber = typeOfTest('number')
const isBoolean = typeOfTest('boolean')
const isUndefined = typeOfTest('undefined')
const isFunction = typeOfTest('function')


```


## 14. 实现深拷贝

```js
function deepClone(obj, map = new WeakMap()) {// @TODO
  if (obj === null || typeof obj !== 'object') {
    return obj;
  }
  
  // 处理循环引用
  if (map.has(obj)) {
    return map.get(obj);
  }
  
  // 根据对象类型创建相应的容器
  let clone;
  if (obj instanceof Date) {
    clone = new Date(obj.getTime());
  } else if (obj instanceof RegExp) {
    clone = new RegExp(obj.source, obj.flags);
  } else if (Array.isArray(obj)) {
    clone = [];
  } else {
    clone = {};
  }
  
  // 记录已拷贝的对象
  map.set(obj, clone);
  
  // 递归拷贝所有属性
  for (let key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) {
      clone[key] = deepClone(obj[key], map);
    }
  }
  
  return clone;
}
```

## 15. 最大并发数限制的请求调度器

```js

```

## 16. 实现异步队列

```js

```

## 17. 实现LRU缓存

```js

```

## 18. 解析URL参数

```js
function parseURLParams(url) {// @TODO
  const params = {};
  // 提取URL中的查询字符串部分
  const queryString = url.split('?')[1];
  if (!queryString) return params;
  
  // 分割参数
  const pairs = queryString.split('&');
  
  for (const pair of pairs) {
    // 处理有等号和无等号的情况
    const [key, value = ''] = pair.split('=');
    // 解码URL编码的字符
    params[decodeURIComponent(key)] = decodeURIComponent(value);
  }
  
  return params;
}

// 使用URLSearchParams API的简化版本
function parseURLParamsModern(url) {
  const params = new URLSearchParams(url.split('?')[1]);
  return Object.fromEntries(params.entries());
}
```

## 19. 实现睡眠函数

```js
function sleep(ms) {// @TODO
  return new Promise(resolve => setTimeout(resolve, ms));
}

// 使用示例
async function demo() {
  console.log('开始');
  await sleep(1000);
  console.log('延迟1秒后');
}
```

## 20. 实现数组原型方法

### forEach
```js
Array.prototype.myForEach = function(callback, thisArg) {// @TODO
  for (let i = 0; i < this.length; i++) {
    callback.call(thisArg, this[i], i, this);
  }
};
```

### map
```js
Array.prototype.myMap = function(callback, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    result.push(callback.call(thisArg, this[i], i, this));
  }
  return result;
};
```

### filter
```js
Array.prototype.myFilter = function(callback, thisArg) {
  const result = [];
  for (let i = 0; i < this.length; i++) {
    if (callback.call(thisArg, this[i], i, this)) {
      result.push(this[i]);
    }
  }
  return result;
};
```

## 21 jquery渲染表格，模拟虚拟DOM
```html
<script src="https://cdn.bootcdn.net/ajax/libs/jquery/1.10.0/jquery.min.js"></script>

<body>
    <div id="container"></div>
    <button id="change-btn">change</button>

    <script>
        var data = [{
            name: '张三',
            age: 18,
            sex: '男'
        },
        {
            name: '李四',
            age: 19,
            sex: '男'
        },
        {
            name: '王五',
            age: 20,
            sex: '男'
        }
        ]


        // 渲染函数*/
        var render = function (data) { // todo
            var $container = $('#container');
            
            // 清空容器
            $container.empty();
            
            // 使用字符串拼接创建整个表格
            var tableHTML = '<table>';
            
            // 添加表头
            tableHTML += '<thead><tr><th>姓名</th><th>年龄</th><th>性别</th></tr></thead>';
            
            // 添加表格内容
            tableHTML += '<tbody>';
            data.forEach(function(item, index) {
                tableHTML += '<tr>';
                tableHTML += '<td>' + item.name + '</td>';
                tableHTML += '<td>' + item.age + '</td>';
                tableHTML += '<td>' + item.sex + '</td>';
                tableHTML += '</tr>';
            });
            tableHTML += '</tbody>';
            tableHTML += '</table>';
            
            // 将整个表格HTML添加到容器
            $container.append(tableHTML);
        }


        $('#change-btn').click(function () {
            data[0].name = 'zhangsan'
            data[1].age = 21
            render(data)
        })

        render(data)
    </script>
</body>


``` 

## 总结

