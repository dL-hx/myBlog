# 黑马程序员前端面试必看视频教程目录


## Day 01: JavaScript 核心基础

2. **如何确认 this 的值** - 13:57
3. **如何指定 this 的值** - 12:22
4. **手写 call 方法 01-核心功能** - 19:27
5. **手写 call 方法 02-Symbol 调优** - 08:49
6. **手写 apply 方法** - 09:49
7. **手写 bind 方法** - 12:22
8. **class 核心语法** - 14:49
9. **class 实现继承** - 10:22
10. **class 静态属性和私有属性** - 12:04
11. **寄生组合继承** - 14:24
12. **fetch 核心语法** - 15:50
13. **fetch 提交 FormData** - 08:36
14. **fetch 提交 JSON** - 11:33
15. **Generator 核心语法** - 13:16
16. **Generator 管理异步** - 09:50

## Day 02: 手写 Promise 全系列

1. **手写 promise-核心功能-构造函数** - 11:25
2. **手写 promise-核心功能-状态及原因** - 12:22
3. **手写 Promise-核心功能-then 方法-成功和失败回调** - 14:52
4. **手写 Promise-核心功能-then 方法-异步及多次调用** - 13:50
5. **手写 Promise-核心功能-异步任务-核心 api** - 13:58
6. **手写 Promise-核心功能-异步任务-函数封装** - 13:14
7. **手写 Promise-核心功能-链式编程-处理异常和普通内容** - 19:12
8. **手写 Promise-核心功能-链式编程-处理返回 Promise** - 11:11
9. **手写 Promise-核心功能-链式编程-处理重复引用** - 08:17
10. **手写 Promise-核心功能-链式编程-rejected 状态** - 12:24
11. **手写 Promise-链式编程-pending 状态** - 10:28
12. **手写 Promise-实例方法-catch** - 08:20
13. **手写 Promise-实例方法-finally** - 05:36
14. **手写 Promise-静态方法-resolve** - 08:59
15. **手写 Promise-静态方法-reject** - 03:24
16. **手写 Promise-静态方法-race** - 13:37
17. **手写 Promise-静态方法-all(实现到判断空数组)-修复** - 09:33
18. **手写 Promise-.静态方法-all(全部兑现及第一个拒绝)** - 14:13
19. **手写 Promise-静态方法-allSettled-核心用法** - 08:45
20. **手写 Promise-静态方法-allSettled-实现** - 14:19
21. **手写 Promise-静态方法-any-核心用法** - 08:18
22. **手写 Promise-静态方法-any-实现** - 15:16
23. **手写 Promise-PromiseAplus 测试** - 19:06

## Day 03: 函数柯里化与设计模式

1. **函数柯里化-介绍** - 07:42
2. **函数柯里化-面试题** - 12:16
3. **函数柯里化-面试题-调优** - 07:39
4. **函数柯里化应用-类型判断** - 11:46
5. **设计模式-工厂模式** - 10:31
6. **设计模式-单例模式-自己实现单例方法** - 09:30
7. **设计模式-单例模式-源码学习** - 11:23
8. **设计模式-观察者模式** - 03:39
9. **设计模式-发布订阅模式-实现$on和$emit** - 22:10
10. **设计模式-发布订阅模式-实现$off和$once** - 10:38
11. **设计模式-原型模式** - 08:30
12. **设计模式-代理模式** - 15:13
13. **设计模式-迭代器模式-forin 和 forof** - 09:04
14. **迭代器模式-可迭代对象** - 19:22

## Day 04: 性能优化 - 防抖与节流

1. **防抖的适用场景** - 11:09
   防止页面出现抖动
2. **防抖的实现** - 11:12

- 开启定时器
- 清除已开启的定时器
  ![alt text](assets/前端面试题/Snipaste_2025-11-05_16-30-24.png)

3. **防抖工具函数 debounce** - 08:31

## React 中实现 Input 搜索防抖

在 React 应用中，实现输入框搜索防抖需要注意以下几点：

1. 使用 useRef 保存定时器 ID，确保不会被组件重新渲染清除
2. 使用 useCallback 包裹处理函数，避免不必要的重新创建
3. 在组件卸载时清除定时器，防止内存泄漏

### 方法一：基础实现

```jsx
import React, { useState, useRef, useEffect } from "react";

function SearchInput() {
  const [searchTerm, setSearchTerm] = useState("");
  const [results, setResults] = useState([]);
  // 使用useRef保存定时器ID
  const debounceTimeoutRef = useRef(null);

  const handleSearch = (value) => {
    // 清除之前的定时器
    if (debounceTimeoutRef.current) {
      clearTimeout(debounceTimeoutRef.current);
    }

    // 设置新的定时器
    debounceTimeoutRef.current = setTimeout(() => {
      // 模拟API调用
      console.log("搜索:", value);
      // fetchResults(value).then(setResults);
    }, 500);
  };

  const handleInputChange = (e) => {
    const value = e.target.value;
    setSearchTerm(value);
    handleSearch(value);
  };

  // 组件卸载时清除定时器
  useEffect(() => {
    return () => {
      if (debounceTimeoutRef.current) {
        clearTimeout(debounceTimeoutRef.current);
      }
    };
  }, []);

  return (
    <div>
      <input
        type="text"
        value={searchTerm}
        onChange={handleInputChange}
        placeholder="搜索..."
      />
      <div>
        {results.map((result, index) => (
          <div key={index}>{result}</div>
        ))}
      </div>
    </div>
  );
}

export default SearchInput;
```

### 方法二：自定义 Hook 实现（最推荐的）

```jsx
import React, { useState, useEffect, useRef, useCallback } from "react";

// 自定义防抖Hook
function useDebounce(value, delay) {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

function SearchInput() {
  const [searchTerm, setSearchTerm] = useState("");
  const [results, setResults] = useState([]);
  // 使用自定义Hook获取防抖后的值
  const debouncedSearchTerm = useDebounce(searchTerm, 500);

  // 使用useCallback优化搜索函数
  const fetchResults = useCallback(async (term) => {
    if (!term.trim()) {
      setResults([]);
      return;
    }

    try {
      // 实际项目中这里会调用API
      console.log("执行搜索:", term);
      // const response = await fetch(`/api/search?query=${encodeURIComponent(term)}`);
      // const data = await response.json();
      // setResults(data);
    } catch (error) {
      console.error("搜索失败:", error);
    }
  }, []);

  // 当防抖后的值变化时执行搜索
  useEffect(() => {
    fetchResults(debouncedSearchTerm);
  }, [debouncedSearchTerm, fetchResults]);

  return (
    <div>
      <input
        type="text"
        value={searchTerm}
        onChange={(e) => setSearchTerm(e.target.value)}
        placeholder="搜索..."
      />
      <div className="search-results">
        {results.length === 0 ? (
          <div className="no-results">{searchTerm && "无搜索结果"}</div>
        ) : (
          results.map((result, index) => (
            <div key={index} className="result-item">
              {result}
            </div>
          ))
        )}
      </div>
    </div>
  );
}

export default SearchInput;
```
![alt text](assets/前端面试题/Snipaste_2025-11-05_16-53-34.png)

```js
const func = function (e) {
  console.log(e.target.value);
  rederCity(this.value);
};
const debounce = function (func, wait) {
  let timerId;
  return function (...args) {
    let _this = this;
    clearTimeout(timerId);
    timerId = setTimeout(() => {
      func.apply(_this, args);
    }, wait);
  };
};

const debounceFunc = debounce(func, 500);

document.getElementById("search-input").addEventListener("input", debounceFunc);





```



5. **节流的适用场景和手写** - 15:58
![alt text](assets/前端面试题/Snipaste_2025-11-05_17-37-36.png)
![alt text](assets/前端面试题/Snipaste_2025-11-05_17-41-30.png)

![alt text](assets/前端面试题/Snipaste_2025-11-05_17-52-47.png)


6. **节流工具函数 throttle** - 12:24
   ```javascript
   var video = document.getElementById('video')

    video.addEventListener('loadeddata', function () {
       video.currentTime = localStorage.getItem('currentTime') || 0
    })

   // 使用节流优化
   const func = function () {
     console.log('timeupdate触发')
     localStorage.setItem('currentTime', this.currentTime)
   }
   
   const throttleFn = _.throttle(func, 3000, { leading: false })
   
   video.addEventListener('timeupdate', throttleFn)

   ```
7. **手写节流工具函数 throttle** - 15:27

```js
const func = function (e) {
  console.log('timeupdate触发')
  console.log('e:', e)
  localStorage.setItem('currentTime', this.currentTime)
}


function throttle(func, wait = 0) {
  // TODO
  let timeId = undefined
  return function (...args) {
    let _this = this
    if (timeId !== undefined) {
        return;
    }

    timeId = setTimeout(() => {
      func.apply(_this, args)
      timeId = undefined
    }, wait)
  }
}


const throttleFn = throttle(func, 1000)
video.addEventListener('timeupdate', throttleFn)

```

8. **防抖和节流总结** - 07:07

## 核心知识点总结

### JavaScript 基础

- **this 绑定机制**：确认和指定 this 值
- **函数原型方法**：手写 call、apply、bind 方法
- **面向对象编程**：class 语法、继承、静态属性和私有属性
- **异步编程**：fetch API、Generator 函数

### Promise 深入理解

- **Promise 核心实现**：构造函数、状态管理、then 方法
- **链式调用**：异常处理、Promise 返回值处理
- **Promise API**：实例方法(catch、finally)和静态方法(resolve、reject、race、all、allSettled、any)
- **PromiseA+规范**：符合规范的 Promise 实现与测试

### 函数式编程

- **函数柯里化**：概念、实现和应用
- **类型判断**：使用柯里化优化类型检测

### 设计模式

- **创建型模式**：工厂模式、单例模式、原型模式
- **行为型模式**：观察者模式、发布订阅模式、迭代器模式
- **结构型模式**：代理模式

### 性能优化

- **防抖(Debounce)**：适用场景和实现
- **节流(Throttle)**：适用场景和实现
- **性能优化策略**：何时使用防抖，何时使用节流
